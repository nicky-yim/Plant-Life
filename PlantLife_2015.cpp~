/***********************************************************
           CSC D18, Fall 2015, UTSC
                 PlantLife.cpp

  Learning Goals:

   After completing this assignment you should be able to

   * Design and implement objects as a hierarchy or parts
     related by transformations
   * Do simple animation of hierarchical objects
   * Understand how plant structures can be generated by
     using a small set of rules working on strings of
     symbols
   * Understand and use illumination in OpenGL
   * Use simple functions to generate a ground surface map.

  What to do:

   * Read the handout! it contains important details about
     the work you are supposed to do here and explains
     how L-systems (used to generate the plants) work.
   * Read the comments in this starter file, which detail
     what the existing code does and indicate what needs
     doing.
   * Complete all the parts marked // TO DO:
   * Add any // CRUNCHY:  extensions you want
   * Test thoroughly and make sure it works on mathlab
   * Complete the CHECKLIST!

Note on glui: If you have a newer version of Linux that does
 	not provide the glui library, download the glui
	package from the course website and uncompress it to
	the current directory.

Program Code V3.0: F. Estrada, Sep 2012.
	Last update, Jun, 2015
***********************************************************/

// OpenGL libraries
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>
//#include <GL/glui.h>	// Use this if the glui library is installed in your
			// system
#include "glui.h"	// Use this if the glui components are within the
			// current directory

// Standard UNIX/C libraries
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <unistd.h>

#define MAX_PLANTS 25		// Maximum number of plants for plant forests
#define GRID_RESOLVE 65		// Size of the surface grid
/******************************************************************************
  Data structures section
*******************************************************************************/
// Tree structure used to hold the plant model for rendering (remember the
// hierarchical rendering we discussed in tutorial, and you used for A1!)
struct PlantNode{
  char type;         // Node type, a=stem, b=stem, c=leaf, d=flower    - You may add your own types as needed
  GLfloat z_ang;     // Rotation of this node w.r.t. parent's z-axis   - Rotates around the current stem direction
  GLfloat x_ang;     // Rotation of this node w.r.t. parent's x-axis   - Rotates away from current stem direction
  GLfloat scl;       // Local scale for this node

  GLfloat f_c_R;     // Colour for this node's component - You can use it if needed, for example, to give
  GLfloat f_c_G;     // flowers different colours.
  GLfloat f_c_B;
  GLfloat misc_A;	     // Misc variables A to C are UNDEFINED. You can use them any way you want to create
  GLint misc_B;      // different types of structures for the stems, leafs, and flowers.
  GLint misc_C;

  struct PlantNode *left;     // Left child for this node (NULL means the node is a terminal)
  struct PlantNode *right;    // Right child for this node (NULL means the node is a terminal)

  // QUESTION: We don't have a translation component... WHY?

  // NOTE: We don't have pointers to the parents. Make sure your drawing function knows what
  // it's doing!
};

/******************************************************************************
  Global data
******************************************************************************/
int Opening_animation=0;
const float PI = 3.14159;
double side = 15;   // Width of the surface grid
struct PlantNode *PlantForest[MAX_PLANTS];	// Array of pointers for a plant forest, use when drawing multiple plants
GLfloat ForestXYZ[MAX_PLANTS][3];		// Location of plants in the forest as (x, y, z)
GLfloat GroundXYZ[GRID_RESOLVE][GRID_RESOLVE][3];	// Array to store ground surface points as (x,y,z) points
GLfloat GroundNormals[GRID_RESOLVE][GRID_RESOLVE][3];   // Array to hold normal vectors at vertices (will use normal to triangle
                                                        // defined by the vertices at [i][j], [i+1][j], and [i][j+1]

// Texture data
int textures_on;				// Flag to indicate texturing should be enabled for leafs/flowers
GLuint l_texture,p_texture;			// Identifiers for OpenGL texture data for leaf and petal
int l_sx,l_sy,p_sx,p_sy;
unsigned char *leaf_texture;			// Pointer to leaf texture data (RGBA)
unsigned char *petal_texture;			// Pointer to petal texture data (RGBA)

// Window settings and GLUI variables
int windowID;               // Glut window ID (for display)
int Win[2];                 // window (x,y) size

// GLUI interface variables
GLUI *glui;
GLfloat global_Z;	    // User controlled global rotation around Z
GLfloat global_scale;       // User controlled global scale factor

// Command-line parameters - These affect the shape of the plants, and control the number of plants in the forest
GLfloat Z_angle;      // Max angle around local Z-axis for each level
GLfloat X_angle;      // Max angle around local X-axis at each branching point
GLfloat scale_mult;   // Scale multiplier for children. Children nodes have scale=(scale_mult*parent_scale);
GLint n_levels;       // Number of levels of branching in the plant
GLint n_plants;	      // Number of plants in a plant forest in [1,MAX_PLANTS]

// Transition probabilities for the L-system specification
GLfloat Paab;
GLfloat Paac;
GLfloat Paad;
GLfloat Pacd;
GLfloat Pba;
GLfloat Pbc;
GLfloat Pbd;

// Scatter mode variables
int scatter_mode = 0;
int numBoids;
GLfloat Boid_Location[MAX_PLANTS*4096][3]; // NOTE: Each plant has O(2^n_levels) leaf or
GLfloat Boid_Velocity[MAX_PLANTS*4096][3]; //     flower nodes. In main(), n_levels is
                                           //     restricted to be <= 12, thus 2^12=4096.
char Boid_Type[MAX_PLANTS*4096];    // Leaf or Flower Node.
bool initYet = false;
float r_rule1,r_rule2,r_rule3,k_rule1,k_rule2,k_rule3;

/******************************************************************************
  Function Prototypes
*******************************************************************************/
// Initialization functions
void initGlut(char* winName);
void initGlui();
unsigned char *readPPM(const char *name, int *sx, int *sy);

// Callbacks for handling events in glut
void WindowReshape(int w, int h);
void WindowDisplay(void);

// L-system generation, rendering, and animation
struct PlantNode *MakePlant(void);
void GenerateRecursivePlant(struct PlantNode *p, int level);
void FreePlant(struct PlantNode *p);
void PrintPlant(struct PlantNode *p);
void printNodeRecursive(struct PlantNode *p, int lev, int tgt);
void RenderPlant(struct PlantNode *p);
void StemEnd();
void StemSection();
void LeafStemSection();
void drawLeaf();
void drawTextureLeaf();
void LeafSection();
void drawFlower();
void drawTextureFlower();
void FlowerSection();
void AnimatedRenderPlant(void);
void setupPlant(struct PlantNode *p);
void updatePlant(struct PlantNode *p);
void resetPlant(struct PlantNode *p);
bool checkForest();
bool checkPlant(struct PlantNode *p);
void initBoid();
void initBoidRecursive(struct PlantNode *p);
void updateBoid(int i);
float sign(float x){if (x>=0) return(1.0); else return(-1.0);}
void draw_square();


// Surface generation
void MakeSurfaceGrid(void);
void RenderSurfaceGrid(void);
void computeNormal(double *vx, double *vy, double *vz, double wx, double wy, double wz);

/**************************************************************************
 Program Code starts
**************************************************************************/
void computeNormal(double *vx, double *vy, double *vz, double wx, double wy, double wz)
{
 //
 // I'm giving you a handy small function to compute the normal to a surface
 // given two vectors known to be on that surface (e.g. two sides of a GL_QUAD
 // or GL_TRIANGLE).
 //
 // Notice that it returns the normal in vx, vy, vz, hence these are expected
 // to be pointers
 //
 // Example call:
 //     vx = .25;
 //     vy = .12;
 //     vz = -.1;
 //     wx = .5;
 //     wy = -.3;
 //     wz = .25;
 //     computeNormal(&vx, &vy, &vz, wx, wy, wz);
 //
 // The returned normal has unit length.
 //

 double len;
 double nx,ny,nz;

 len=sqrt(((*vx)*(*vx))+((*vy)*(*vy))+((*vz)*(*vz)));
 *(vx)=(*vx)/len;
 *(vy)=(*vy)/len;
 *(vz)=(*vz)/len;

 nx=((*vy)*wz)-(wy*(*vz));
 ny=(wx*(*vz))-((*vx)*wz);
 nz=((*vx)*wy)-(wx*(*vy));

 len=sqrt((nx*nx)+(ny*ny)+(nz*nz));
 nx/=len;
 ny/=len;
 nz/=len;

 *(vx)=nx;
 *(vy)=ny;
 *(vz)=nz;
}

void RenderSurfaceGrid(void)
{
 // Render the surface grid defined by the vertices in GroundXYZ

 /////////////////////////////////////////////////////////////////////////
 // TODO: Write code to draw the surface map you generated.
 //       Remember that you have vertices on a square grid. You can
 //       easily determine (or you can look at the notes!) how to
 //       create GL_QUADS, or GL_TRIANGLES from the vertices in the
 //       grid (but we know that only one of these types of shapes
 //       can be reliably assumed to be flat given its vertices)
 //
 //       Don't forget to specify the normal at each vertex. Otherwise
 //       your surface won't be properly illuminated
 /////////////////////////////////////////////////////////////////////////
 

 glBegin(GL_TRIANGLES);
 // Soil
 glColor3f(.2,.05,0);
 
 // Grass
 //glColor3f(0,.28,0); 
 
 // Draw each tile with 2 diagonal triangles.
 // eg. ---     --/
 //     | |  -> |/|
 //     ---     /-|
 for (int i=1; i<GRID_RESOLVE; i++) {
   for (int j=1; j<GRID_RESOLVE; j++) {
     //glColor3f(drand48(),drand48(),drand48());
     glNormal3f(GroundNormals[i-1][j-1][0],GroundNormals[i-1][j-1][1],GroundNormals[i-1][j-1][2]);
     glVertex3f(GroundXYZ[i-1][j-1][0],GroundXYZ[i-1][j-1][1],GroundXYZ[i-1][j-1][2]);
     glNormal3f(GroundNormals[i][j-1][0],GroundNormals[i][j-1][1],GroundNormals[i][j-1][2]);
     glVertex3f(GroundXYZ[i][j-1][0],GroundXYZ[i][j-1][1],GroundXYZ[i][j-1][2]);
     glNormal3f(GroundNormals[i][j][0],GroundNormals[i][j][1],GroundNormals[i][j][2]);
     glVertex3f(GroundXYZ[i][j][0],GroundXYZ[i][j][1],GroundXYZ[i][j][2]);

     //glColor3f(drand48(),drand48(),drand48());
     glNormal3f(GroundNormals[i][j][0],GroundNormals[i][j][1],GroundNormals[i][j][2]);
     glVertex3f(GroundXYZ[i][j][0],GroundXYZ[i][j][1],GroundXYZ[i][j][2]);
     glNormal3f(GroundNormals[i-1][j][0],GroundNormals[i-1][j][1],GroundNormals[i-1][j][2]);
     glVertex3f(GroundXYZ[i-1][j][0],GroundXYZ[i-1][j][1],GroundXYZ[i-1][j][2]);
     glNormal3f(GroundNormals[i-1][j-1][0],GroundNormals[i-1][j-1][1],GroundNormals[i-1][j-1][2]);
     glVertex3f(GroundXYZ[i-1][j-1][0],GroundXYZ[i-1][j-1][1],GroundXYZ[i-1][j-1][2]);
   }
 }
 glEnd();

}

void diasqr(int left, int top, int right, int bottom, double base_height)
{
  // Diamond-Square algorithm adapted from the source code of:
  // http://www.paulboxley.com/blog/2011/03/terrain-generation-mark-one
  int x_centre, y_centre;
  double centre_point_value, height;
  
  x_centre = (left + right) / 2;
  y_centre = (top + bottom) / 2;
  height = (drand48() - 0.5) * base_height * 2;
  
  // Diamond Step
  centre_point_value = ((GroundXYZ[left][top][2] + GroundXYZ[right][top][2]
    + GroundXYZ[left][bottom][2] + GroundXYZ[right][bottom][2]) / 4.0) - height;
  GroundXYZ[x_centre][y_centre][2] = centre_point_value;
  
  // Square Step
  GroundXYZ[x_centre][top][2] = ((GroundXYZ[left][top][2] + GroundXYZ[right][top][2]
    + centre_point_value) / 3) + ((drand48() - 0.5) * base_height);
  GroundXYZ[x_centre][bottom][2] = ((GroundXYZ[left][bottom][2] + GroundXYZ[right][bottom][2]
    + centre_point_value) / 3) + ((drand48() - 0.5) * base_height);
  GroundXYZ[left][y_centre][2] = ((GroundXYZ[left][top][2] + GroundXYZ[left][bottom][2]
    + centre_point_value) / 3) + ((drand48() - 0.5) * base_height);  
  GroundXYZ[right][y_centre][2] = ((GroundXYZ[right][top][2] + GroundXYZ[right][bottom][2]
    + centre_point_value) / 3) + ((drand48() - 0.5) * base_height);

  // Since we separate the grid into 4 smaller grids, we perform DiamondSquare algorithm
  // on these 4 grids recursively.
  if ((right - left) > 2) {
    base_height = base_height * pow(2, -0.9);
    diasqr(left,top,x_centre,y_centre,base_height);
    diasqr(x_centre,top,right,y_centre,base_height);
    diasqr(left,y_centre,x_centre,bottom,base_height);
    diasqr(x_centre,y_centre,right,bottom,base_height);
  }
}

void MakeSurfaceGrid(void)
{
 // Generate an interesting surface to place the plants on

 /////////////////////////////////////////////////////////////////////////
 // TODO: Write code to generate a surface map. I am already giving you
 //       a skeleton that fills an array of vertices corresponding to
 //       locations on a square grid. The square grid is defined on the
 //       XY plane, and your job is to determine the value of Z at each
 //       location (i.e. determine the height of the surface at that
 //       point).
 //
 // 	  You should implement a procedural model for ground generation
 //	  such as the diamond-square method. There's a link on the handout
 //       to information about it, or you can research other ways to create
 //       terrain maps. Whatever you do. Document it within this function
 //       and add a reference to where you found the method.
 //
 //       Do not forget to set the normals to the surface!
 //
 //       The surface coordinates are stored in GroundXYZ[][][]
 //       The normals are stored in GroundNormals[][][]
 //
 //       NOTE: when you assign locations to the plants in your forest,
 //             make sure the pant's root location agrees with the
 //             surface height at the point where it is rooted.
 //             We don't want plants sinking into the ground!
 /////////////////////////////////////////////////////////////////////////

 double height;
 double vx,vy,vz,wx,wy,wz;

 // Assign surface heights
 //side=15;				// Width of the surface - X and Y coordinates
 					// will have values in [-side/2, side/2]

 // REPLACE THE SIMPLE LOOP BELOW THAT MAKES A FLAT SURFACE WITH YOUR CODE
 // FOR PROCEDURAL GROUND GENERATION.
 for (int i=0; i<GRID_RESOLVE; i++)
  for (int j=0; j<GRID_RESOLVE; j++)
  {
   GroundXYZ[i][j][0]=(-side*.5)+(i*(side/GRID_RESOLVE));
   GroundXYZ[i][j][1]=(-side*.5)+(j*(side/GRID_RESOLVE));
   GroundXYZ[i][j][2]=0;
   //printf("%f,%f,%f\n", (float)GroundXYZ[i][j][0], (float)GroundXYZ[i][j][1], (float)GroundXYZ[i][j][2]);
  }
 
 // initial height for the four corners randomly.
 height = 2;
 GroundXYZ[0][0][2] = height * (drand48() - .5);
 GroundXYZ[GRID_RESOLVE-1][0][2] = height * (drand48() - .5);
 GroundXYZ[0][GRID_RESOLVE-1][2] = height * (drand48() - .5);
 GroundXYZ[GRID_RESOLVE-1][GRID_RESOLVE-1][2] = height * (drand48() - .5);
 
 // diamond-square algorithm
 diasqr(0, GRID_RESOLVE-1, GRID_RESOLVE-1, 0, height);
 
 // Compute normals at each vertex
 // Remember we talked about how to compute the normal for a triangle in lecture. You
 // can do the same thing here.
 //
 // NOTE: Be careful with indexing along the borders of the surface grid! you will
 //       run into all sorts of problems if you don't think carefully what you're
 //       doing.
 for (int i=1; i<GRID_RESOLVE; i++)
  for (int j=1; j<GRID_RESOLVE; j++)
  {
   // Obtain two vectors on the surface the point at GroundXYZ[i][j][] is located
   vx = GroundXYZ[i][j-1][0] - GroundXYZ[i-1][j-1][0];
   vy = GroundXYZ[i][j-1][1] - GroundXYZ[i-1][j-1][1];
   vz = GroundXYZ[i][j-1][2] - GroundXYZ[i-1][j-1][2];
   
   wx = GroundXYZ[i-1][j][0] - GroundXYZ[i-1][j-1][0];
   wy = GroundXYZ[i-1][j][1] - GroundXYZ[i-1][j-1][1];
   wz = GroundXYZ[i-1][j][2] - GroundXYZ[i-1][j-1][2];
   // Then compute the normal
   computeNormal(&vx,&vy,&vz,wx,wy,wz);

   // And store it...
   GroundNormals[i-1][j-1][0]=vx;    // <----- HEY!
   GroundNormals[i-1][j-1][1]=vy;    // <----- REPLACE THESE COMPONENTS with the correct
   GroundNormals[i-1][j-1][2]=vz;    // <----- normal for your surface!
  }
}

void setupPlant(struct PlantNode *p) {
    // For animation mode
	// Copy PlantNode's scale to misc_A then set to 0.
	if (p==NULL) return;
	
	p->misc_A = p->scl;
	p->scl = 0;
	
	if (p->left != NULL) setupPlant(p->left);
	if (p->right != NULL) setupPlant(p->right);
	return;
}

void updatePlant(struct PlantNode *p)
{
 // Growing plants by increasing the scale size of each node,
 // by each level. So like if level 0 has scl .8, then when
 // animation mode is selected, level 0 is drawn with 0 scale.
 // Each iteration increases its scale by [-.01, .01]. Once its
 // scale gets to .8, the next iteration draws level 0 as it original
 // scale size, then start increasing level 1's scale size.
 if (p==NULL) return;
 if (p->scl < p->misc_A) {
   // Plants grow in a random rate
   p->scl += drand48() / 100;
   if (p->scl > p->misc_A) p->scl = p->misc_A;
 	 /*if (p->scl + .01 > p->misc_A) {
 	   p->scl = p->misc_A;
   } else {
     p->scl += .01;
   }*/
 } else {
	 if (p->left!=NULL) updatePlant(p->left);
	 if (p->right!=NULL) updatePlant(p->right);
 }
 return;
}

void resetPlant(struct PlantNode *p) {
	// Reset PlantNode's scale to original.
	if (p==NULL) return;
	
	p->scl = p->misc_A;
	
	if (p->left != NULL) resetPlant(p->left);
	if (p->right != NULL) resetPlant(p->right);
	return;
}

bool checkForest() {
	// Checks if every level in every plants is at its original scale.
	// if true then it means animation is done
	bool res = true;
	for (int i=0; i<n_plants; i++) {
		res = res && checkPlant(PlantForest[i]);
	}
	return res;
}

bool checkPlant(struct PlantNode *p) {
	// Recursively check if each node is back to its original scale size.
	bool res = true;
	if (p==NULL) return true;
	if (p->scl < p->misc_A) {
		return false;
	}
	if (p->left!=NULL) res = res && checkPlant(p->left);
	if (p->right!=NULL) res = res && checkPlant(p->right);
	return res;
}

void AnimatedRenderPlant(void)
{
 // This function animates the growth of all plants in the plant
 // forest.
 // It retains control as long as the animation is incomplete,
 // drawing each frame and swapping buffers as needed. Once
 // the animation is completed, control returns to the
 // display function.

 // More information is provided under 'CRUNCHY' in the display
 // function...
 glui->sync_live();
 glPushMatrix();
 glScalef(global_scale,global_scale,global_scale);
 glRotatef(global_Z,0,0,1);
 RenderSurfaceGrid();
 
 // If the forest is back to its scale then we just go back to normal mode
 if (checkForest()) {
   Opening_animation = 0;
   glutPostRedisplay();
   return;
 }
 
 // Draw as usual. Note that when drawing, nodes' scl is changing.
 for (int i=0; i<n_plants; i++) {
   glPushMatrix();
     glTranslatef(ForestXYZ[i][0],ForestXYZ[i][1],ForestXYZ[i][2]);
	 	 RenderPlant(PlantForest[i]);
	 glPopMatrix(); 
 }
 
 // And here is how we change nodes' scl
 for (int i=0; i<n_plants; i++) {
   updatePlant(PlantForest[i]);
 }
 glPopMatrix();
 
 glFlush();
 glutSwapBuffers();
 glutPostRedisplay(); // Force to call glut's display function to get animation
}

void RenderPlant(struct PlantNode *p)
{
 // Recursive rendering function for the plant. Renders the
 // section specified by p after performing the transformations
 // required to give this part the correct orientation and
 // position.

 ////////////////////////////////////////////////////////////
 // TO DO: Complete this function to draw the plant as a
 //        hierarchical structure. Hint: This will involve
 //        performing a tree-traversal in the proper order
 //
 // NOTE: Since the plant has a pre-defined number of levels,
 //       many 'branches' will end in a symbol corresponding
 //       to a stem section (a or b). You should draw
 //       something at the end of these last-level stems,
 //       else your plant will look 'dried up'.
 ////////////////////////////////////////////////////////////

  // a -> ab with p = Paab
  // a -> ac with p = Paac
  // a -> ad with p = Paad
  // a -> cd with p = Pacd
  // b -> a  with p = Pba
  // b -> c  with p = Pbc
  // b -> d  with p = Pbd

 bool stem_end = true;

 if (p==NULL) return;		// Avoid crash if called with empty node
 glPushMatrix();
 glColor3f(.25,1,.1);
 glScalef(p->scl,p->scl,p->scl);
 glRotatef(p->z_ang,0,0,1);
 glRotatef(p->x_ang,1,0,0);
 //StemSection();
 //glPopMatrix();
 
 if (p->type=='a' || p->type=='b') {
   if (p->left==NULL && p->right==NULL) {
     // Last-level stems
     StemEnd();
   } else {
     if (!scatter_mode) {
       StemSection();
       glPushMatrix();
         glTranslatef(0,0,1); 
         RenderPlant(p->left);
       glPopMatrix();
       
       glPushMatrix();
         glTranslatef(0,0,1);
         RenderPlant(p->right);
       glPopMatrix();
     } else {
       // In scatter mode, if node p has a child and it's a leaf or flower,
       // we treat(draw) it as a last-level stems 
       if (p->left != NULL) {
         if (p->left->type=='a' || p->left->type=='b') {
           stem_end = false;
         }
       }
       if (p->right != NULL) {
         if (p->right->type=='a' || p->right->type=='b') {
           stem_end = false;
         }
       }
       if (stem_end) { StemEnd();
       } else {
         StemSection();
         glPushMatrix();
           glTranslatef(0,0,1); 
           RenderPlant(p->left);
         glPopMatrix();
       
         glPushMatrix();
           glTranslatef(0,0,1);
           RenderPlant(p->right);
         glPopMatrix();
       }
     }
   }
 } else if (p->type=='c') {
   if (!scatter_mode) { LeafSection();
   } else {
   // if in scatter mode, we don't draw the leaves or flowers here
     if (!initYet) {
       // if we haven't set boid location we do so
       float m[16];
       glGetFloatv(GL_MODELVIEW_MATRIX,m);
       Boid_Location[p->misc_B][0]=m[12];
       Boid_Location[p->misc_B][1]=m[13];
       Boid_Location[p->misc_B][2]=m[14];
     }
   }
 } else {
   if (!scatter_mode) { FlowerSection();
   } else {
     if (!initYet) {
       float m[16];
       glGetFloatv(GL_MODELVIEW_MATRIX,m);
       Boid_Location[p->misc_B][0]=m[12];
       Boid_Location[p->misc_B][1]=m[13];
       Boid_Location[p->misc_B][2]=m[14];
     }
   }
 }
 
 glPopMatrix();
}

void StemEnd()
{
  // Draws the tip of last-level stems such that the plants 
  // don't look 'dried up'.

  GLUquadric *quadObject;
  quadObject=gluNewQuadric();

  // e.g. "=====>" instead of "======"
  gluCylinder(quadObject,.05,.01,.6,10,10);
  gluCylinder(quadObject,.01,0,.4,10,10); // pointy stem

  // Destroy our quadrics object
  gluDeleteQuadric(quadObject);
}

void StemSection()
{
  // Draws a single stem section, along the current local Z axis
  // I'm giving you this function already so you can at least see
  // the 'skeleton' of your plant to help debug the L-system.

  // Create a quadrics object to make the stem
  GLUquadric *quadObject;
  quadObject=gluNewQuadric();

  gluCylinder(quadObject,.05,.04,1,10,10);

  // Destroy our quadrics object
  gluDeleteQuadric(quadObject);
}

void LeafStemSection()
{
  // Draws the little stem before the leaf.

  // Create a quadrics object to make the stem
  GLUquadric *quadObject;
  quadObject=gluNewQuadric();

  gluCylinder(quadObject,.04,.02,.5,10,10);

  // Destroy our quadrics object
  gluDeleteQuadric(quadObject);
}

void drawLeaf()
{
   double vx, vy, vz, wx, wy, wz;
   // draw leaf on x-z plane
   // NOTE: 1 Leaf node consists of 1 big leaf and 1 small leaf
   glBegin(GL_POLYGON);
     vx = .5;
     vy = .1;
     vz = .35;
     wx = -.5;
     wy = .1;
     wz = .35;
     computeNormal(&vx, &vy, &vz, wx, wy, wz);
     glNormal3f(vx,vy,vz);
     glVertex3f(0,0,0);
     vx = -.5;
     vy = -.1;
     vz = -.35;
     wx = .2;
     wy = .1;
     wz = .55;
     computeNormal(&vx, &vy, &vz, wx, wy, wz);
     glNormal3f(vx,vy,vz);
     glVertex3f(.5,.1,.35);
     vx = -.2;
     vy = -.1;
     vz = -.55;
     wx = -.2;
     wy = .1;
     wz = .5;
     computeNormal(&vx, &vy, &vz, wx, wy, wz);
     glNormal3f(vx,vy,vz);
     glVertex3f(.7,.2,.9);
     vx = .2;
     vy = -.1;
     vz = -.5;
     wx = -.5;
     wy = .1;
     wz = .6;
     computeNormal(&vx, &vy, &vz, wx, wy, wz);
     glNormal3f(vx,vy,vz);
     glVertex3f(.5,.3,1.4);
     vx = .5;
     vy = -.1;
     vz = -.6;
     wx = -.5;
     wy = -.1;
     wz = -.6;
     computeNormal(&vx, &vy, &vz, wx, wy, wz);
     glNormal3f(vx,vy,vz);
     glVertex3f(0,.4,2);
     vx = .5;
     vy = .1;
     vz = .6;
     wx = -.2;
     wy = -.1;
     wz = -.5;
     computeNormal(&vx, &vy, &vz, wx, wy, wz);
     glNormal3f(vx,vy,vz);
     glVertex3f(-.5,.3,1.4);
     vx = .2;
     vy = .1;
     vz = .5;
     wx = .2;
     wy = -.1;
     wz = -.55;
     computeNormal(&vx, &vy, &vz, wx, wy, wz);
     glNormal3f(vx,vy,vz);
     glVertex3f(-.7,.2,.9);
     vx = -.2;
     vy = .1;
     vz = .55;
     wx = .5;
     wy = -.1;
     wz = -.35;
     computeNormal(&vx, &vy, &vz, wx, wy, wz);
     glNormal3f(vx,vy,vz);
     glVertex3f(-.5,.1,.35);
   glEnd();
   
   // smaller leaf
   glBegin(GL_POLYGON);
     vx = .25;
     vy = .1;
     vz = -.15;
     wx = -.25;
     wy = .1;
     wz = -.15;
     computeNormal(&vx, &vy, &vz, wx, wy, wz);
     glNormal3f(vx,vy,vz);
     glVertex3f(0,0,0);
     vx = -.25;
     vy = -.1;
     vz = .15;
     wx = .1;
     wy = .1;
     wz = -.3;
     computeNormal(&vx, &vy, &vz, wx, wy, wz);
     glNormal3f(vx,vy,vz);
     glVertex3f(.25,.1,-.15);
     vx = -.1;
     vy = -.1;
     vz = .3;
     wx = -.1;
     wy = .1;
     wz = -.25;
     computeNormal(&vx, &vy, &vz, wx, wy, wz);
     glNormal3f(vx,vy,vz);
     glVertex3f(.35,.2,-.45);
     vx = .1;
     vy = -.1;
     vz = .25;
     wx = -.25;
     wy = .1;
     wz = -.3;
     computeNormal(&vx, &vy, &vz, wx, wy, wz);
     glNormal3f(vx,vy,vz);
     glVertex3f(.25,.3,-.7);
     vx = .25;
     vy = -.1;
     vz = .3;
     wx = -.25;
     wy = -.1;
     wz = .3;
     computeNormal(&vx, &vy, &vz, wx, wy, wz);
     glNormal3f(vx,vy,vz);
     glVertex3f(0,.4,-1);
     vx = .25;
     vy = .1;
     vz = -.3;
     wx = -.1;
     wy = -.1;
     wz = .25;
     computeNormal(&vx, &vy, &vz, wx, wy, wz);
     glNormal3f(vx,vy,vz);
     glVertex3f(-.25,.3,-.7);
     vx = .1;
     vy = .1;
     vz = -.25;
     wx = .1;
     wy = -.1;
     wz = .3;
     computeNormal(&vx, &vy, &vz, wx, wy, wz);
     glNormal3f(vx,vy,vz);
     glVertex3f(-.35,.2,-.45);
     vx = -.1;
     vy = .1;
     vz = -.3;
     wx = .25;
     wy = -.1;
     wz = .15;
     computeNormal(&vx, &vy, &vz, wx, wy, wz);
     glNormal3f(vx,vy,vz);
     glVertex3f(-.25,.1,-.15);
   glEnd();
}

void draw_square()
{
  glColor3f(1,1,1);
  glBegin(GL_POLYGON);
  glNormal3f(0,0,1);
  glVertex3f(-.5,-.5,0);
  glVertex3f(-.5,.5,0);
  glVertex3f(.5,.5,0);
  glVertex3f(.5,-.5,0);
  glEnd();
}

void drawTextureLeaf()
{
   // draw leaf on x-z plane
   // NOTE: 1 Leaf node consists of 1 big leaf and 1 small leaf
   glBegin(GL_POLYGON);
     glNormal3f(0,1,0);
     glTexCoord2f(.5,0);
     glVertex2f(0,0);

     glTexCoord2f((.5+1.7)/1.4,.35/2);
     glVertex2f(.5,.35);

     glTexCoord2f(1,.9/2);
     glVertex2f(.7,.9);

     glTexCoord2f((.5+.7)/1.4,1.4/2);
     glVertex2f(.5,1.4);

     glTexCoord2f(.5,1);
     glVertex2f(0,2);

     glTexCoord2f((-.5+.7)/1.4,1.4/2);
     glVertex2f(-.5,1.4);

     glTexCoord2f(0,.9/2);
     glVertex2f(-.7,.9);

     glTexCoord2f(.2/1.4,.35/2);
     glVertex2f(-.5,.35);
   glEnd();
}

void LeafSection(void)
{
 // Draws a single leaf, along the current local Z axis
 // Note that we draw a little stem before the actual leaf.
 glColor3f(.30,1,.1);
 LeafStemSection();

 // Perhaps you should translate now? :)
 glPushMatrix();
   glTranslatef(0,0,.5);
   
 /* Sphere leaves for testing
  GLUquadric *quadObject;
  quadObject=gluNewQuadric();

  gluSphere(quadObject,.2,10,10);

  // Destroy our quadrics object
  gluDeleteQuadric(quadObject);
 */


 ////////////////////////////////////////////////////////////
 // TO DO: Draw your own leaf design.
 //        It should be aligned with the current Z
 //        axis, and all transformations for positioning
 //        and orienting the leaf in the plant should be
 //        done outside. However, *any* transformations
 //        required to actually draw the leaf should be
 //        done here.
 //
 //        You must draw a leaf using polygons (or quads, or
 //        triangles), and must design it yourself. You
 //        are not allowed to use GLUT objects to draw the
 //        leaf. Also, rotate away from the stem so that the
 //        leaf will point *away* from the growing plant
 //
 //        Note you must provide proper normal vectors for
 //        vertices in your leaf so that it can be correctly
 //        illuminated by OpenGL.
 //
 //        How to obtain the leaf's vertext coordinates?
 //        I use quadriculated paper...
 ////////////////////////////////////////////////////////////

 ////////////////////////////////////////////////////////////
 // CRUNCHY: Use texture mapping to create nicer leaves!
 //          I am setting up the OpenGL texture mapping
 //          configuration for you, your work is in creating
 //          the polygon shape, normals, and texture coordinates
 //          for your leaf. This may in fact end up being
 //          simpler than defining a very complex, non-textured
 //          leaf.
 ////////////////////////////////////////////////////////////

 // Enable texture mapping if needed (see main() to enable texturing)
 if (textures_on)
 {
  glEnable(GL_TEXTURE_2D);
  // Enable Alpha-blending
  glEnable (GL_BLEND);
  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glEnable(GL_CULL_FACE);
  glBindTexture(GL_TEXTURE_2D,l_texture);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
  drawTextureLeaf();
 } else {
  // rotate away from the stem
  glRotatef(90,1,0,0);
  drawLeaf();
 }

 // Disable texture mapping
 if (textures_on)
 {
  glDisable(GL_CULL_FACE);
  glDisable(GL_TEXTURE_2D);
  glDisable (GL_BLEND);
 }
 
 glPopMatrix();
}

void drawFlower()
{
 /// Petals
 double vx, vy, vz, wx, wy, wz;
 glBegin(GL_POLYGON);
 vx = -.5;
 vy = 0;
 vz = -.5;
 wx = .5;
 wy = -.5;
 wz = -.5;
 computeNormal(&vx,&vy,&vz,wx,wy,wz);
 glNormal3f(vx,vy,vz);
 glVertex3f(.25,.75,.25);
 vx = -.5;
 vy = .5;
 vz = .5;
 wx = 0;
 wy = -.5;
 wz = .5;
 computeNormal(&vx,&vy,&vz,wx,wy,wz);
 glNormal3f(vx,vy,vz);
 glVertex3f(.75,.25,-.25);
 vx = 0;
 vy = .5;
 vz = -.5;
 wx = -.5;
 wy = -.5;
 wz = -.5;
 computeNormal(&vx,&vy,&vz,wx,wy,wz);
 glNormal3f(vx,vy,vz);
 glVertex3f(.75,-.25,.25);
 vx = .5;
 vy = .5;
 vz = .5;
 wx = -.5;
 wy = 0;
 wz = .5;
 computeNormal(&vx,&vy,&vz,wx,wy,wz);
 glNormal3f(vx,vy,vz);
 glVertex3f(.25,-.75,-.25);
 vx = .5;
 vy = 0;
 vz = -.5;
 wx = -.5;
 wy = .5;
 wz = -.5;
 computeNormal(&vx,&vy,&vz,wx,wy,wz);
 glNormal3f(vx,vy,vz);
 glVertex3f(-.25,-.75,.25);
 vx = .5;
 vy = -.5;
 vz = .5;
 wx = 0;
 wy = .5;
 wz = .5;
 computeNormal(&vx,&vy,&vz,wx,wy,wz);
 glNormal3f(vx,vy,vz);
 glVertex3f(-.75,-.25,-.25);
 vx = 0;
 vy = -.5;
 vz = -.5;
 wx = .5;
 wy = .5;
 wz = -.5;
 computeNormal(&vx,&vy,&vz,wx,wy,wz);
 glNormal3f(vx,vy,vz);
 glVertex3f(-.75,.25,.25);
 vx = -.5;
 vy = -.5;
 vz = .5;
 wx = -.5;
 wy = 0;
 wz = -.5;
 computeNormal(&vx,&vy,&vz,wx,wy,wz);
 glNormal3f(vx,vy,vz);
 glVertex3f(-.25,.75,-.25);
 glEnd();
 
 // Carpel
 glColor3f(1,1,0);
 glPushMatrix();
 glTranslatef(0,0,.25);
 GLUquadric *my_quad;
 my_quad=gluNewQuadric();
 gluSphere(my_quad,.25,10,10);
 gluDeleteQuadric(my_quad);
 glPopMatrix();
}

void drawTextureFlower()
{
 glBegin(GL_POLYGON);
 glNormal3f(0,0,1);
 
 glTexCoord2f(.5,0);
 glVertex2f(0,0);
 
 glTexCoord2f(1.2/2,.4);
 glVertex2f(.2,.4);
 
 glTexCoord2f(1,.5);
 glVertex2f(1,.5);
 
 glTexCoord2f(1.2/2,.6);
 glVertex2f(.2,.6);
 
 glTexCoord2f(.5,1);
 glVertex2f(0,1);
 
 glTexCoord2f(.8/2,.6);
 glVertex2f(-.2,.6);
 
 glTexCoord2f(0,.5);
 glVertex2f(-1,.5);
 
 glTexCoord2f(.8,.4);
 glVertex2f(-.2,.4);

 glEnd();
}

void FlowerSection()
{
 glColor3f(1,0,0);
 //LeafStemSection();
 //glPushMatrix();
 //  glTranslatef(0,0,.5);
   
 // Draws a flower perpendicular to the current local Z axis

 /////////////////////////////////////////////////////////////
 // TO DO: Add code to draw a flower,
 //        It should be perpendicular to the Z axis, i.e.
 //        it should have the same orientation as the local
 //        x-y plane.
 //        Same conditions about transformations apply as for
 //        leaves.
 //
 //        DO NOT use GLU and GLUT shapes for this, design
 //        your own leaf shape using standard GL polygons
 //        and lines. Mind the fact you will have to define
 //        surface normals for your shapes otherwise
 //        illumination will not work
 /////////////////////////////////////////////////////////////

 /////////////////////////////////////////////////////////////
 // CRUNCHY: Use texture mapping to create nicer flowers!
 //          Should be easy if you already texture mapped
 //          the leaves.
 /////////////////////////////////////////////////////////////

 // Enable texture mapping (you must also enable it in main()! )
 if (textures_on)
 {
  glEnable(GL_TEXTURE_2D);
  // Enable Alpha-blending
  glEnable (GL_BLEND);
  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glEnable(GL_CULL_FACE);
  glBindTexture(GL_TEXTURE_2D,p_texture);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
  drawTextureFlower();
 } else {
  glColor3f(1,0,0);
  drawFlower();
 }

 // Disable texture mapping
 if (textures_on)
 {
  glDisable(GL_CULL_FACE);
  glDisable(GL_TEXTURE_2D);
  glDisable (GL_BLEND);
 }
 //glPopMatrix();
}

void FreePlant(struct PlantNode *p)
{
 // Release all memory allocated to the plant structure
 if (p==NULL) return;
 if (p->left!=NULL) FreePlant(p->left);
 if (p->right!=NULL) FreePlant(p->right);
 free(p);
}

void PrintPlant(struct PlantNode *p)
{
 // Tree traversal to print the plant structure
 // To enable viewing the structure of the plant,
 // Nodes are printed by level, note that this is
 // different from what you may need to do to
 // render the plant (which would be a depth-first
 // hierarchical structure)
 int l;

 for (l=0;l<n_levels;l++)
 {
  fprintf(stderr,"Level %02d\n",l);
  printNodeRecursive(p,0,l);
  fprintf(stderr,"\n");
 }

}

void printNodeRecursive(struct PlantNode *p, int lev, int tgt)
{
 if (p==NULL) return;
 if (lev==tgt)
 {
  fprintf(stderr,"%c ",p->type);
  return;
 }

 if (p->left!=NULL) printNodeRecursive(p->left,lev+1,tgt);
 if (p->right!=NULL) printNodeRecursive(p->right,lev+1,tgt);

 fprintf(stderr," ");
 return;
}

struct PlantNode *MakePlant(void)
{
  // This function creates a plant with the specified
  // characteristics given by the global plant parameters
  // and a set of internal parameters that govern the
  // probability of specific parts being generated
  // at each level.
  //
  // The rules for generating the plant are as follows:
  //
  // Four types of components:  a - Plant stem
  //                            b - Plant stem
  //                            c - Leaf
  //                            d - flower
  //
  // You will use the node types to render each plant
  // component appropriately.
  //
  // The generation rules for the plant structure are
  //
  // a -> ab with p = Paab
  // a -> ac with p = Paac
  // a -> ad with p = Paad
  // a -> cd with p = Pacd
  // b -> a  with p = Pba
  // b -> c  with p = Pbc
  // b -> d  with p = Pbd
  // c and d are terminal nodes.
  //
  // The probabilities for transitions are parameters to
  // the function so that you can generate different
  // types of plants.
  //
  // NOTE: The transition probabilities from a *MUST*
  // add up to 1. The transition probabilities from
  // b *MUST* also add up to 1.
  // Also, because of the probabilistic nature of the
  // generation process, you can not guarantee the plant
  // will have the specified numer of levels!
  //
  // If you add your own node types, you will have to
  // update the generation rules, and add appropriate
  // parameters to determine transition probabilities
  // for any additional components.
  //
  // Finally, the random number seed is set in main(),
  // but could be made an input parameter to obtain more
  // random behaviour.

  struct PlantNode *p_root=NULL;

  p_root=(struct PlantNode *)calloc(1,sizeof(struct PlantNode)); // Allocate new tree root
  p_root->type='a';                                              // Always start with a stem
  p_root->z_ang=0;                                               // which is vertical w.r.t
  p_root->x_ang=0;                                               // global coordinate frame
  p_root->scl=.8+(.2*drand48());                                 // Initial scale (defines the size
                                                                 // of the largest component).
  p_root->left=NULL;
  p_root->right=NULL;

  // Generative part, use the laws above to generate up to two children for each node in the tree
  GenerateRecursivePlant(p_root,1);  // Level 0 is the root, next level is 1
  return(p_root);
}

void GenerateRecursivePlant(struct PlantNode *p, int level)
{
  // Generates child nodes for parent 'p' with p being at level 'level'
  // if level>n_levels, stop.
  float dice;
  struct PlantNode *q, *r;

  q=r=NULL;

  if (p==NULL) return;                     // Reached a terminal
  if (level>=n_levels) return;             // Reached maximum plant height
  if (p->type=='c'||p->type=='d') return;  // c and d type nodes are terminal nodes as well

  dice=drand48();           // Roll the dice...
  if (p->type=='a')
  {
   /////////////////////////////////////////////////////////////
   // TO DO: Complete this part, select a replacement rule for
   //        this node based on the probabilities stated above
   //        (also found in the handbook), and add the appropriate
   //        nodes to the plant tree. This is implemented below
   //        for 'b' type nodes, and you can look at that code
   //        to give you an idea how the process works.
   /////////////////////////////////////////////////////////////
    q=(struct PlantNode *)calloc(1,sizeof(struct PlantNode));
    q->x_ang=drand48()*X_angle;
    q->z_ang=drand48()*Z_angle;
    q->left=NULL;
    q->right=NULL;
    q->scl=scale_mult * p->scl;
    
    r=(struct PlantNode *)calloc(1,sizeof(struct PlantNode));
    r->x_ang=drand48()*X_angle;
    r->z_ang=drand48()*Z_angle;
    r->left=NULL;
    r->right=NULL;
    r->scl=scale_mult * p->scl;

    // a -> ab with p = Paab
    // a -> ac with p = Paac
    // a -> ad with p = Paad
    // a -> cd with p = Pacd
    if (dice<=Paab)
      {
        q->type='a';
        r->type='b';
      }
    else if (dice<=(Paab+Paac))
      {
        q->type='a';
        r->type='c';
      }
    else if (dice<=(Paab+Paac+Paad))
      {
        q->type='a';
        r->type='d';
      }
    else
      {
        q->type='c';
        r->type='d';
      }
  }
  else if (p->type=='b')
  {
    // Generate a single node for either left or right
    q=NULL;
    r=(struct PlantNode *)calloc(1,sizeof(struct PlantNode));
    r->x_ang=drand48()*X_angle;
    r->z_ang=drand48()*Z_angle;
    //r->scl=scale_mult;
    r->scl= scale_mult * p->scl;
    r->left=NULL;
    r->right=NULL;

    if (dice<=Pba)
      {
	// Selected rule b -> a
        r->type='a';
      }
    else if (dice<=(Pba+Pbc))
      {
        // Selected rule b -> c
        r->type='c';
      }
    else
      {
        // Selected rule b -> d
        r->type='d';
      }
  }
  else {fprintf(stderr,"Bad node type!\n"); return;}

  // Decide which node goes to left and which goes right randomly
  if (drand48()<=.5)
    {
      p->left=q;
      p->right=r;
    }
  else
    {
      p->left=r;
      p->right=q;
    }

  // Recursive call for children
  GenerateRecursivePlant(p->left,level+1);
  GenerateRecursivePlant(p->right,level+1);
}

void initBoid() {
  for (int i=0;i<n_plants;i++) {
    initBoidRecursive(PlantForest[i]);
  }
  for (int i=0; i<numBoids; i++) {
    Boid_Velocity[i][0]=0;
    Boid_Velocity[i][1]=0;
    Boid_Velocity[i][2]=0;
  }
  for (int i=0;i<n_plants;i++) RenderPlant(PlantForest[i]);
  initYet = true;
}

void initBoidRecursive(struct PlantNode *p) {
  if (p==NULL) return;
  if (p->type=='c') {
    p->misc_B = numBoids;
    Boid_Type[numBoids] = 'c';
    numBoids++;
  }
  if (p->type=='d') {
    p->misc_B = numBoids;
    Boid_Type[numBoids] = 'd';
    numBoids++;
  }
  if (p->left!=NULL) initBoidRecursive(p->left);
  if (p->right!=NULL) initBoidRecursive(p->right);
}

void updateBoid(int i) {
  // copied from my a1 submission, except i removed paco's rule 0.
  float V1[3];
  float V2[3];
  float V3[3];
  float centerMass[3];
  float dist=0.0;
  float temp=0.0;

  centerMass[0]=centerMass[1]=centerMass[2]=0.0;
  V1[0]=V1[1]=V1[2]=0.0;
  
    for (int x=0; x<numBoids; x++)
    {
      //if (x != i) {
        for (int z=0; z<3; z++){
          temp = Boid_Location[x][z] - Boid_Location[i][z];
          dist += temp * temp;
        }
        // dist = sqrt(x^2 + y^2 + z^2) where x,y,z
        // are components of vector from Boid[i] to Boid[x]
        if (sqrt(dist) < r_rule1){
          centerMass[0] += Boid_Location[x][0];
          centerMass[1] += Boid_Location[x][1];
          centerMass[2] += Boid_Location[x][2];
        }
      //}
      dist = 0.0; // reset
    }
    centerMass[0] = centerMass[0] / numBoids;
    centerMass[1] = centerMass[1] / numBoids;
    centerMass[2] = centerMass[2] / numBoids;
    // ^ Now we have the position of center of mass
    
    V1[0] = centerMass[0] - Boid_Location[i][0];
    V1[1] = centerMass[1] - Boid_Location[i][1];
    V1[2] = centerMass[2] - Boid_Location[i][2];

    Boid_Velocity[i][0] += k_rule1 * V1[0];
    Boid_Velocity[i][1] += k_rule1 * V1[1];
    Boid_Velocity[i][2] += k_rule1 * V1[2];
    
    V2[0] = 0.0;
    V2[1] = 0.0;
    V2[2] = 0.0;

    for (int j=0; j<numBoids; j++){
        if (j != i) {
            for (int z=0; z<3; z++){
              temp = Boid_Location[j][z] - Boid_Location[i][z];
              dist += temp * temp;
            }
            if (sqrt(dist) < r_rule2){
                V2[0] = Boid_Location[j][0] - Boid_Location[i][0];
                V2[1] = Boid_Location[j][1] - Boid_Location[i][1];
                V2[2] = Boid_Location[j][2] - Boid_Location[i][2];
            }
            Boid_Velocity[i][0] -= k_rule2 * V2[0];
            Boid_Velocity[i][1] -= k_rule2 * V2[1];
            Boid_Velocity[i][2] -= k_rule2 * V2[2];
        }
        dist = 0.0;
    }
    
    V3[0] = 0.0;
    V3[1] = 0.0;
    V3[2] = 0.0;

    for (int j=0; j<numBoids; j++) {
        if (j != i) {
            for (int z=0; z<3; z++){
              temp = Boid_Location[j][z] - Boid_Location[i][z];
              dist += temp * temp;
            }
            if (sqrt(dist) < r_rule3){
                V3[0] += Boid_Velocity[j][0];
                V3[1] += Boid_Velocity[j][1];
                V3[2] += Boid_Velocity[j][2];
            }
        }
        dist = 0.0; // reset
    }
    V3[0] = V3[0] / numBoids-1;
    V3[1] = V3[1] / numBoids-1;
    V3[2] = V3[2] / numBoids-1;
    
    Boid_Velocity[i][0] += k_rule3 * V3[0];
    Boid_Velocity[i][1] += k_rule3 * V3[1];
    Boid_Velocity[i][2] += k_rule3 * V3[2];
    
 Boid_Velocity[i][0]=sign(Boid_Velocity[i][0])*sqrt(fabs(Boid_Velocity[i][0]));
 Boid_Velocity[i][1]=sign(Boid_Velocity[i][1])*sqrt(fabs(Boid_Velocity[i][1]));
 Boid_Velocity[i][2]=sign(Boid_Velocity[i][2])*sqrt(fabs(Boid_Velocity[i][2]));
    
 Boid_Location[i][0] += Boid_Velocity[i][0];
 Boid_Location[i][1] += Boid_Velocity[i][1];
 Boid_Location[i][2] += Boid_Velocity[i][2];
 
 return;
    
}

int main(int argc, char** argv)
{
 /*
   Parse input line parameters, enforce reasonable bounds on global variables
   and parameters for the L-system, and set up plant structures.
 */

    // Process program arguments
    if(argc != 15) {
        printf("Usage: PlantLife n_plants n_levels X_angle Z_angle scale_mult Paab Paac Paad Pacd Pba Pbc Pbd width height\n");
        exit(1);
    } else {
        n_plants=atoi(argv[1]);
        n_levels=atoi(argv[2]);
        X_angle=atof(argv[3]);
        Z_angle=atof(argv[4]);
        scale_mult=atof(argv[5]);
        Paab=atof(argv[6]);
        Paac=atof(argv[7]);
        Paad=atof(argv[8]);
        Pacd=atof(argv[9]);
        Pba=atof(argv[10]);
        Pbc=atof(argv[11]);
        Pbd=atof(argv[12]);
        Win[0] = atoi(argv[13]);
        Win[1] = atoi(argv[14]);

        // Enforce bounds on input variables
        if (n_plants>=MAX_PLANTS) n_plants=MAX_PLANTS;
        if (n_plants<=0) n_plants=1;
        if (n_levels<3) n_levels=3;
        if (n_levels>12) n_levels=12;
        if (X_angle<10) X_angle=50;
        if (X_angle>90) X_angle=90;
        if (Z_angle<10) Z_angle=10;
        if (Z_angle>360) Z_angle=360;
        if (scale_mult<.75) scale_mult=.75;
        if (scale_mult>.99) scale_mult=.99;
	Paab=Paab/(Paab+Paac+Paad+Pacd);
	Paac=Paac/(Paab+Paac+Paad+Pacd);
	Paad=Paad/(Paab+Paac+Paad+Pacd);
	Pacd=Pacd/(Paab+Paac+Paad+Pacd);
        Pba=Pba/(Pba+Pbc+Pbd);
        Pbc=Pbc/(Pba+Pbc+Pbd);
        Pbd=Pbd/(Pba+Pbc+Pbd);
        if (Win[0]<250) Win[0]=250;
        if (Win[0]>1024) Win[0]=1024;
        if (Win[1]<250) Win[1]=250;
        if (Win[1]>1024) Win[1]=1024;

	////////////////////////////////////////////////
        // CRUNCHY - If you are going to use textures
        //           for your leafs and flowers, update
        //           the code below.
        //           Make sure the input images are
        //           available and have a square size
        //           which is a power of 2. A reasonable
        //           size would be 256x256, don't use
        //           huge textures or you'll pay in
        //           rendering performance.
	    //
        //           You MUST
        //           submit your texture images along
        //           with your completed code.
        ////////////////////////////////////////////////
	textures_on=0;		// Set to 1 to enable texturing
        if (textures_on)
        {
	 leaf_texture=readPPM("leaf_texture_image.ppm",&l_sx,&l_sy);	// Evidently, you must change this to be
									// your leaf texture image in .ppm format!
	 petal_texture=readPPM("petal_texture_image.ppm",&p_sx,&p_sy);	// Similarly, set this to be your petal
									// texture image.
         if (!leaf_texture||!petal_texture)
         {
          fprintf(stderr,"main(): Unable to load textures. Texture mapping disabled\n");
          textures_on=0;
         }
         else fprintf(stderr,"Textures read and stored\n");
        }
    }

    // Initialize OpenGL - Take a moment to read through these functions!
    glutInit(&argc, argv);
    initGlut(argv[0]);
    initGlui();

    // Initialize all data arrays
    memset(&GroundXYZ[0][0][0],0,GRID_RESOLVE*GRID_RESOLVE*3*sizeof(GL_FLOAT));
    memset(&GroundNormals[0][0][0],0,GRID_RESOLVE*GRID_RESOLVE*3*sizeof(GL_FLOAT));
    memset(&ForestXYZ[0][0],0,n_plants*3*sizeof(GL_FLOAT));

    // Generate surface map
    MakeSurfaceGrid();

    // Make a plant forest!
    for (int i=0;i<n_plants;i++)
     PlantForest[i]=MakePlant();

    //////////////////////////////////////////////////////////////
    // TO DO: Set the locations of the plants in the plant forest
    //        randomly in X,Y, but at the correct height for
    //        the corresponding location in the surface grid.
    //////////////////////////////////////////////////////////////
    float plantx, planty;
    float plantz = 0;
    int loc;
    for (int i=0;i<n_plants;i++) {
      loc = rand() % (GRID_RESOLVE - 1);
      plantx = (-side*.5)+(loc*(side/GRID_RESOLVE));
      loc = rand() % (GRID_RESOLVE - 1);
      planty = (-side*.5)+(loc*(side/GRID_RESOLVE));
      for (int x=0;x<GRID_RESOLVE;x++) {
        for (int y=0;y<GRID_RESOLVE;y++) {
          if ((GroundXYZ[x][y][0] == plantx) && 
              (GroundXYZ[x][y][1] == planty)) {
            plantz = GroundXYZ[x][y][2];
          }
        }
      }
      ForestXYZ[i][0] = plantx;
      ForestXYZ[i][1] = planty;
      ForestXYZ[i][2] = plantz;
    }

		// Backup node scale for animation
		if (Opening_animation) {
		  for (int i=0;i<n_plants;i++) {
			  setupPlant(PlantForest[i]);
		  }
		}
		
    // Intialize global transformation variables and GLUI
    global_Z=0;
    global_scale=15;
    glui->sync_live();
    
    // Boid updates control variables
    r_rule1=15;
    r_rule2=8;
    r_rule3=25;
    k_rule1=.15;
    k_rule2=.5;
    k_rule3=.15;

    // Invoke the standard GLUT main event loop
    glutMainLoop();
    return 0;         // never reached
}

// Initialize glut and create a window with the specified caption
void initGlut(char* winName)
{
    // Set video mode: double-buffered, color, depth-buffered
    glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH);

    // Create window
    glutInitWindowPosition (0, 0);
    glutInitWindowSize(Win[0],Win[1]);
    windowID = glutCreateWindow(winName);

    // Setup callback functions to handle events
    glutReshapeFunc(WindowReshape);   
    glutDisplayFunc(WindowDisplay);

    // Texturing stuff - load textures to the graphics-card memory
    // once!
    if (textures_on)
    {
     glGenTextures( 1, &l_texture);
     glBindTexture( GL_TEXTURE_2D, l_texture);

     glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
     glTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
     glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, l_sx, l_sy, 0, GL_RGBA, GL_UNSIGNED_BYTE, leaf_texture);

     glGenTextures( 1, &p_texture);
     glBindTexture( GL_TEXTURE_2D, p_texture);

     glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
     glTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
     glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, p_sx, p_sy, 0, GL_RGBA, GL_UNSIGNED_BYTE, petal_texture);
    }
}

// Handles the window being resized by updating the viewport
// and projection matrices
void WindowReshape(int w, int h)
{
    // Setup projection matrix for new window
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    // We will use perspective projection. The camera is at (100,100,100)
    // looking at (0,0,0) - the origin -, with the Z axis pointing upward
    gluPerspective(60,1,15,500);
    gluLookAt(150,150,150,0,0,50,0,0,1);

    // Update OpenGL viewport and internal variables
    glViewport(0,0, w,h);
    Win[0] = w;
    Win[1] = h;
}

// Animation button handler.
void animation(int)
{
  scatter_mode = 0;
  if (Opening_animation == 0) {
    // Play animation
    Opening_animation = 1;
    for (int i=0; i<n_plants; i++) setupPlant(PlantForest[i]);
  } else {
    // In case user presses animation button when animation is being played
    //Opening_animation = 0;
    for (int i=0; i<n_plants; i++) {
      resetPlant(PlantForest[i]);
    } 
  }
  glutPostRedisplay();
}

// Scatter button handler.
void scatter(int)
{
  scatter_mode = 1 - scatter_mode;
  if (Opening_animation) {
  // In case user presses scatter button when doing animation
    for (int i=0; i<n_plants; i++) {
      resetPlant(PlantForest[i]);
    }
    Opening_animation = 0;
  }
  if (!initYet) initBoid(); // self-explanatory...
  glutPostRedisplay();
}

// Quit button handler.  Called when the "quit" button is pressed.
void quitButton(int)
{
  for (int i=0; i<n_plants; i++) FreePlant(PlantForest[i]);
  exit(0);
}

// Initialize GLUI and the user interface
void initGlui()
{
    GLUI_Master.set_glutIdleFunc(NULL);

    // Create GLUI window
    glui = GLUI_Master.create_glui("PlantLife Window", 0, Win[0]+10, 0);

    ///////////////////////////////////////////////////////////
    // TO DO: Add the controls for global rotation and scale
    //        as specified. Variables are already provided:
    //        global_Z      <--- global rotation around Z
    //        global_scale  <--- global scaling
    //
    //        global_Z must be in [-180, 180]
    //        global_scale must be in [0, 20]
    ///////////////////////////////////////////////////////////

    GLUI_Spinner *gz_spinner
        = glui->add_spinner("global_Z", GLUI_SPINNER_FLOAT, &global_Z);
    gz_spinner->set_speed(1.0);
    gz_spinner->set_float_limits(-180, 180, GLUI_LIMIT_CLAMP);
    
    GLUI_Spinner *gs_spinner
        = glui->add_spinner("global_scale", GLUI_SPINNER_FLOAT, &global_scale);
    gs_spinner->set_speed(3.0);
    gs_spinner->set_float_limits(0, 20, GLUI_LIMIT_CLAMP);

    glui->add_button("Animation", 0, animation);
    
    glui->add_button("Scatter", 0, scatter);    
    
    glui->add_separator();
    
    //    EXAMPLE control for r_rule1
//    Controller name ---|
//                       v
      GLUI_Spinner *r1_spinner
          = glui->add_spinner("r_rule1", GLUI_SPINNER_FLOAT, &r_rule1);
//                              ^               ^               ^
//    Text to show -------------|               |               |
//    Type of control variable -----------------|               |
//    Variable whose value will be changed ---------------------|
//
//    Change speed ----------|
//                           v
      r1_spinner->set_speed(5.0);
      r1_spinner->set_float_limits(10, 100, GLUI_LIMIT_CLAMP);
//                                   ^  ^
//    Min and max values ------------|--|

      GLUI_Spinner *k1_spinner
          = glui->add_spinner("k_rule1", GLUI_SPINNER_FLOAT, &k_rule1);
      k1_spinner->set_speed(0.5);
      k1_spinner->set_float_limits(0, 1, GLUI_LIMIT_CLAMP);

      GLUI_Spinner *r2_spinner
          = glui->add_spinner("r_rule2", GLUI_SPINNER_FLOAT, &r_rule2);
      r2_spinner->set_speed(3.0);
      r2_spinner->set_float_limits(1, 15, GLUI_LIMIT_CLAMP);

      GLUI_Spinner *k2_spinner
          = glui->add_spinner("k_rule2", GLUI_SPINNER_FLOAT, &k_rule2);
      k2_spinner->set_speed(0.5);
      k2_spinner->set_float_limits(0, 1, GLUI_LIMIT_CLAMP);

      GLUI_Spinner *r3_spinner
          = glui->add_spinner("r_rule3", GLUI_SPINNER_FLOAT, &r_rule3);
      r3_spinner->set_speed(5.0);
      r3_spinner->set_float_limits(10, 100, GLUI_LIMIT_CLAMP);

      GLUI_Spinner *k3_spinner
          = glui->add_spinner("k_rule3", GLUI_SPINNER_FLOAT, &k_rule3);
      k3_spinner->set_speed(0.5);
      k3_spinner->set_float_limits(0, 1, GLUI_LIMIT_CLAMP);
    
    // Add "Quit" button
    glui->add_separator();
    glui->add_button("Quit", 0, quitButton);
    glui->add_separator();

    glui->set_main_gfx_window(windowID);
}


void drawAxisLines(void)
{
  // Generate a set of axis at current origin so we can visualize the effect
  // of the transformations... this may be useful to you when trying to
  // figure out what is going on at different points in the plant rendering
  // process.

  // Axes are color coded X=R, Y=G, Z=B
  glColor3f(1.0,0.0,0.0);
  glBegin(GL_LINES);
  glVertex3f(0.0f, 0.0f, 0.0f);
  glVertex3f(500.0f, 0.0f, 0.0f);
  glEnd( );

  glColor3f(0.0,1.0,0.0);
  glBegin(GL_LINES);
  glVertex3f(0.0f, 0.0f, 0.0f);
  glVertex3f(0.0f, 500.0f, 0.0f);
  glEnd( );

  glColor3f(0.0,0.0,1.0);
  glBegin(GL_LINES);
  glVertex3f(0.0f, 0.0f, 0.0f);
  glVertex3f(0.0f, 0.0f, 500.0f);
  glEnd( );
}

// Main drawing function. Callback for scene display
void WindowDisplay(void)
{
		// Opening_animation becomes global variable
    //static int Opening_animation=0;	// Comment the line above and uncomment this line
                                        // if you implemented the plant growing animation.

    // Clear colour buffer and Z-buffer
    glClearColor(0.0f,0.0f,0.0f,1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // Setup the model-view transformation matrix
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glClearDepth(1);
    glEnable(GL_DEPTH_TEST);    // Enable depth testing
    glEnable(GL_LIGHTING);      // Enable lighting
    glEnable(GL_LIGHT0);        // Set up 1 light sources, 1 for diffuse,
    glEnable(GL_LIGHT1);        // 1 for ambient

    glEnable(GL_NORMALIZE);	// Make sure normals stay normalized...

    // Set up light source colour, type, and position
    GLfloat light0_colour[]={.95,.95,.95};
    GLfloat light1_colour[]={.05,.05,.05};
    glLightfv(GL_LIGHT0,GL_DIFFUSE,light0_colour);
    glLightfv(GL_LIGHT1,GL_AMBIENT,light1_colour);
    GLfloat light0_pos[]={2,2,5,0};
    glLightfv(GL_LIGHT0,GL_POSITION,light0_pos);
    glShadeModel(GL_SMOOTH);

    // Enable material colour properties
    glEnable(GL_COLOR_MATERIAL);

    // First time through this function, animate the plants growing (if implemented!)

    ////////////////////////////////////////////////////////////////
    // CRUNCHY: Write a function to animate the plants as they grow.
    //          this function should be called
    //
    //          AnimatedRenderPlant()
    //
    //          and should produce the illusion of plants growing.
    //          Note that a global scaling of the plant WILL NOT
    //          be acceptable. You need to grow the plant level
    //          by level.
    //
    //          The PrintPlant() function may give you ideas
    //          about how to do this.
    //
    //          If you implement this part. Go back to the top
    //          of this function, and uncomment the correct
    //          line that sets the opening animation flat to 1.
    ///////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////
    // SUPREME CRUNCHYNESS OF DOOM: (a.k.a. if you do this Paco will
    //                               be VERY impressed)
    //
    // a)  Add a button to your UI called 'scatter'. When pressed,
    //     all leafs and flowers become Boids and fly away in the
    //     typical Boid patterns from A1. Of course, you can use
    //     any of your A1 code here, and the Boid drawing function
    //     would simply be the same function that draws a leaf
    //     or a flower.
    //
    //    Notice that once the Boids are flying, the plants should
    //     have no leaves or flowers! You may want to scale your
    //     leafs/flowers so as to avoid having a bunch of huge
    //     object/Boids flying around.
    //
    //  or
    //
    //  b) Simulate the changing seasons. Leaves/petals should
    //     change colour accordingly, and fall to the ground
    //     in the fall. There should be a UI button to activate
    //     or trigger this part.
    //
    //     If you are really feeling crunchy, add some falling
    //     snow!
    //
    //     a) and b) are not mutually exclusive. More crunchy
    //     means more bonus!
    //
    //    If you are implementing this and get stuck, come and
    //     talk to me.
    ///////////////////////////////////////////////////////////////

    if (Opening_animation) {
    	AnimatedRenderPlant(); 
    	//Opening_animation=0;
    }
    else
    {
     // synchronize variables that GLUT uses
     glui->sync_live();
     glPushMatrix();
      glScalef(global_scale,global_scale,global_scale);
      glRotatef(global_Z,0,0,1);
      RenderSurfaceGrid();
      draw_square();
      glPushMatrix();
      glTranslatef(0,1,0);
      glScalef(.5,1,1);
      draw_square();

      glPopMatrix();
      glPushMatrix();
  
      glRotatef(45,0,0,1);
      glTranslatef(0,1,0);
      glScalef(.5,1,1);
      glTranslatef(1,0,0);
      draw_square();

      glPopMatrix();
      glTranslatef(0,2,0);
      draw_square();
      //glPopMatrix();
      /*for (int i=0; i<n_plants; i++)
      {
       glPushMatrix();
        glTranslatef(ForestXYZ[i][0],ForestXYZ[i][1],ForestXYZ[i][2]);
        //PrintPlant(PlantForest[i]);
        RenderPlant(PlantForest[i]);
       glPopMatrix();
      }*/
     glPopMatrix();
     
     if (scatter_mode) {
       // Just like in A1
       for (int i=0; i<numBoids; i++) {
         glPushMatrix();
         glTranslatef(Boid_Location[i][0],Boid_Location[i][1],Boid_Location[i][2]);
         glScalef(3,3,3);
         if (Boid_Type[i]=='c') { LeafSection();
         } else { FlowerSection(); };
         glPopMatrix();  
         updateBoid(i);
       }
     }
     
    }
    glFlush();
    glutSwapBuffers();
    if (scatter_mode) glutPostRedisplay();  // No need to keep re-drawing if in normal mode
}

// Utility to read a .ppm file from disk for texture mapping
unsigned char *readPPM(const char *name, int *sx, int *sy)
{
 // Reads an image from a .ppm file. A .ppm file is a very simple image representation
 // format with a text header followed by the binary RGB data at 24bits per pixel.
 // The header has the following form:
 //
 // P6
 // # One or more comment lines preceded by '#'
 // 340 200
 // 255
 //
 // The first line 'P6' is the .ppm format identifier, this is followed by one or more
 // lines with comments, typically used to inidicate which program generated the
 // .ppm file.
 //
 // After the comments, a line with two integer values specifies the image resolution
 // as number of pixels in x and number of pixels in y.
 //
 // The final line of the header stores the maximum value for pixels in the image,
 // usually 255 but does not actually matter for this code as long as it's present.
 //
 // After this last header line, binary data stores the RGB values for each pixel
 // in row-major order at 24bpp.
 //
 // readPPMdata converts the image pixel data to RGBA format by treating all
 // white pixels ([RGB]=[255,255,255]) as fully transparent. It returns an
 // array of sx * sy *4 bytes, where each pixel now has RGBA values.
 //
 // The size of the input image is returned in (sx,sy)

 FILE *f;
 unsigned char *im;
 char line[1024];
 int sizx,sizy;
 int i,j,ly;
 unsigned char *tmp;

 f=fopen(name,"r");
 if (!f){fprintf(stderr,"readPPM(): Unable to open specified image file %s\n",name);return(NULL);}

 fgets(&line[0],1000,f);
 if (strcmp(&line[0],"P6\n")!=0)
 {
  fprintf(stderr,"readPPM(): Wrong file format, not a .ppm file or header data missing\n");
  fclose(f);
  return(NULL);
 }
 // Skip over comments
 fgets(&line[0],511,f);
 while (line[0]=='#')
  fgets(&line[0],511,f);
 sscanf(&line[0],"%d %d\n",&sizx,&sizy);           // Read file size

 *(sx)=sizx;
 *(sy)=sizy;

 im=(unsigned char *)calloc(sizx*sizy*4,sizeof(unsigned char));
 tmp=(unsigned char *)calloc(sizx*sizy*3,sizeof(unsigned char));
 if (!im||!tmp)
 {
  fprintf(stderr,"readPPM(): Unable to allocate memory for image data!\n");
  free(im);
  fclose(f);
  return(NULL);
 }
 fgets(&line[0],9,f);                          		// Read the remaining header line
 fread(tmp,sizx*sizy*3*sizeof(unsigned char),1,f);	// Read image data
 fclose(f);

 // Convert to RGBA
 for (ly=0;ly<3;ly++)
  for (j=0;j<sizy;j++)
   for (i=0;i<sizx;i++)
   {
    *(im+((i+(j*sizx))*4)+0)=*(tmp+((i+(j*sizx))*3)+0);
    *(im+((i+(j*sizx))*4)+1)=*(tmp+((i+(j*sizx))*3)+1);
    *(im+((i+(j*sizx))*4)+2)=*(tmp+((i+(j*sizx))*3)+2);
    if (*(tmp+((i+(j*sizx))*3)+0)==255 && *(tmp+((i+(j*sizx))*3)+1)==255 && *(tmp+((i+(j*sizx))*3)+2)==255)
     *(im+((i+(j*sizx))*4)+3)=0;
    else
     *(im+((i+(j*sizx))*4)+3)=192;
   }

 free(tmp);
 return(im);
}

